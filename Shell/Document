				    Bradley Juma
					
					INTRO	In this Lab we were assigned the difficult task of learning how to build your own custom shell with various of command that are already in the bin, and built in command which the shell original comes with like cd, ls(dir), help ,environ , and so on. This project was split into two parts; Pseudo code, and C Source code, and the pseudo helped me a bit with some of the simple easier functions but not for all.					TESTING			CD		The cd function wasn't a difficult function after discovering about the inbuilt chdir function in the Shell. Using this command allowed me to change to a specified directory just how the original Shell works "cd /Desktop/3207" or just "cd Desktop", and so on. With everything implemented correctly you would now be capable of changing directories, and if not you'll get an error stating "MyShell: too few arguments", stating you aren't declaring to change into any directory. This was then tested by making a directory in my cwd , and attempting to get inside deeper and deeper down the tree, and if no arguments entered got an error.
fork()
.
.
.
fork()	 			Dir		The dir function wasn't too difficult to implement as well after doing some research with some of the functions included in the "#inlcude <dirent.h>" header and that allowed me to create a pointer to the directory, and also another pointer to the the directory which will fall into the "readdir()" family. Using our given libraries helped makes life easier to examine the contents in the directory, and I i wrapped it all in a if state which checks that argv[1] are both set and refer out the cwd. I easily tested thing by checking whether or not the content put inside my directory were being fully displayed.			Echo	The echo functions was definitely top 3 easiest function to implement because it is simply reprinting the arguments that it takes it, and throws it back at you at standard output using the stdout globally declared. It was as simple as if the input argument is empty then print out a new line, and if it's not print out whatever argument was entered, and testing was straight forward, happily getting the output that i expected.			Environ	I was completely confused on how to do this feature for the shell but after some reading, a light bulb rang, and I already has my environment struc with variables set so i created an array of strings and printed it to stdout so I simply used printf, and got all the environment variables to be known, and tested it by checking the if all the environment variables are actively listed.			Help	The help function was difficult but i was confused on how to get the algorithms right, and it was based of the directory the readme was based in, and as soon as i got it works on opening the .txt file It immediately started making a decent read me so someone with little knowledge of the shell is capable of running the program without difficulties.				Pause	This pause function would stop the functionality of the shell when the enter key is press, and it will then print a message to inform the user the user how to proceeed onwards by pressing Enter. This was testing, and was expecting to see something out of stdout to tell me to pressed Enter, and was expecting upon to pressing enter i can go directly back into my shell where I left off.			Quit	This quit function was fairly simple as well using the built in command exit and simple taking in 0 (EXIT_FAILURE, and it was simply tested by quitting out of the shell.			Clear	This function was the easiest to implement imo because it just made a system call which invoked the argument passed into the function which 033 is octal for ESC, and 2J is clearing the entire terminal screen, and H will move the cursor to the upper left corner.			Piping	The piping side was by far the hardest part in my opinion, and I was having allot of trouble the cild process, and since we aren't able to see the child process. When two integers are piped your always suppose to close the i the child process, and not in the parent process so the forks process is what is closed, and I was having too many issues but with allot of debugging I was able to see where the forking is getting to, and testing which process it's getting to. My piping problem comes with calling forks using two independent forks when it should be nested but I cant seem to fully implement the algorithm to fully manipulate piping to work 200%.			Redirection 		File redirection was when things started to really get kinda of tricky, and first thing needed was to create a function that can loop though the argv, and check for the I/O flags in order to help make the job slightly easier. It starts with forking the child process, and informing you if the fork occurred or did not. I used global variables in order to check for the flags which were initially set, and 0, and if it detected I/O based on the flags in our cmdFlag function the file wold the be opening for reading. Allot of the redirection correlated towards the creation of a file descriptor though the open function, and the open func will then truncate or write the file based of the users entered arguments if the file does not exist. This was easily tested by trying out redirection into .txt from echos, and directories with .txt files, and seeing if it's writing/ appending. Hats off to my parsing function for doing its job in order to return a value which is either stdin, out, append, or pipe because without it their were a ton of segmentation faults with how memory was being used for redirection.			Conclusion
	Overall the program was a difficult task but a fun task to tackle because it as easy to test each function as you go as soon as you get the bread and butter down, and with getting the shell going, and slowly testing functions in main, and I extremely loved that as hats my style of coding trying to have as little thing as possible in main, and letting all my functions do the work. I also was interested in excelling my program slightly further with making a mkdir function just to be able to test some function easier like cd once finish and dir making a ton of directions in one folder. Testing all the functions was easy at the end using the batch file but to begin with more of my testing were done in the shells interpreter mode which will give you the same output. I don't particularly love coding so low level in programming but this was indeed an interesting program and was very effective in helping me understand the underlying structure of the shell was which something interesting to learn. Overall i have a ton of bugs which need to be fixed in order for the Shell to be 100% operational in my opinion but wasn't able to get to them all within the time constraint given.